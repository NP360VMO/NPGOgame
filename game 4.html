<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>挑戰遊戲｜飲茶仔 匹配挑戰</title>
  <link rel="stylesheet" href="styles.css">
  <style>
.stage{display:flex;flex-direction:column;align-items:center;gap:10px}.grid{display:grid;grid-template-columns:repeat(8, 50px);gap:6px;user-select:none}.cell{
      width:50px;height:50px;display:flex;align-items:center;justify-content:center;
      font-size:26px;background:#ffffff;border:1px solid #e8e2d6;border-radius:10px;
      cursor:pointer;transition:transform .08s ease, box-shadow .12s ease, border-color .12s ease;
      box-shadow:0 2px 8px rgba(0,0,0,.05)
    }.cell:hover{transform:translateY(-1px)}.cell.selected{border:2px solid #ffb547;box-shadow:0 4px 14px rgba(255,181,71,.25)}.cell.clearing{animation:pop .2s ease both, fade .18s ease forwards}
    @keyframes fade{to{opacity:.25; transform:scale(.8);}}@keyframes pop{from{transform:scale(.85);opacity:.4}to{transform:scale(1.1);opacity:1}}

    .actions{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:12px}.btn:active{transform:translateY(1px)}.hint{margin-top:4px;color:#7a4a00;font-weight:700}@media (max-width:560px){
      .hero{grid-template-columns:84px 1fr}.grid{gap:5px}.cell{width:44px;height:44px;font-size:24px}
</style>
</head>
<body class="theme-dimsum">
  <div class="container">
    <div class="card">
      <div class="header">
        <div class="title">挑戰遊戲 - 飲茶仔（匹配）</div>
        <div class="badge">🎮 挑戰系 · 勝出可解鎖</div>
      </div>

      <div class="hero">
        <div class="img-wrap"><img src="images/game-spirit3.png" alt="飲茶仔"></div>
        <div class="intro">
          <p><strong>玩法：</strong>交換相鄰格子，形成 <strong>3 連以上</strong> 即消除；在限時內累積 <strong>200 分</strong> 解鎖飲茶仔。</p>
          <div class="status-bar">
            <span class="pill info" id="pill-status">尚未開始</span>
            <span class="pill ok" id="pill-score">Score：0 / 200</span>
            <span class="pill warn" id="pill-time">Time：30s</span>
          </div>
          <div class="hint">💡 提示：一次消除超過 3 個會有加分！</div>
          <a class="btn secondary" href="game 4_eng.html">🌐 English Version </a>
        </div>
      </div>

      <div class="section">
        <div class="game-wrap">
          <div class="stage">
            <div id="grid" class="grid" aria-label="match-3 grid"></div>
            <div class="actions">
              <button class="btn" id="btn-start">▶️ 開始遊戲</button>
              <button class="btn secondary" id="btn-retry" style="display:none;">🔁 重新開始</button>
            </div>
          </div>
        </div>
        <div class="actions">
          <a class="btn secondary" href="dex.html#dex">📖 返回圖鑑</a>
          <a class="btn secondary" href="index.html">🔙 返回主頁</a>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">🎉 已解鎖：飲茶仔！</div>

  <script>
    const GRID_SIZE = 8;
    const TYPES = ['🥟','🥮','🥠','🍡','🍤'];
    const gridEl = document.getElementById('grid');
    const pillScore = document.getElementById('pill-score');
    const pillTime  = document.getElementById('pill-time');
    const pillStatus= document.getElementById('pill-status');
    const btnStart  = document.getElementById('btn-start');
    const btnRetry  = document.getElementById('btn-retry');

    let grid = [], score = 0, timeLeft = 30, timerId = null, running = false, selected = null;

    function makeCell(x,y,val){
      const d = document.createElement('div');
      d.className = 'cell';
      d.dataset.x = x; d.dataset.y = y;
      d.textContent = val;
      d.addEventListener('click', onCellClick, {passive:true});
      d.addEventListener('touchstart', (e)=>{ e.preventDefault(); onCellClick({target:d}); }, {passive:false});
      return d;
    }

    function render(){
      gridEl.innerHTML = '';
      for(let i=0;i<GRID_SIZE;i++){
        for(let j=0;j<GRID_SIZE;j++){
          const d = makeCell(i,j,grid[i][j]);
          if(selected && selected.x===i && selected.y===j) d.classList.add('selected');
          gridEl.appendChild(d);
        }
      }
      pillScore.textContent = `Score：${score} / 200`;
      pillTime.textContent  = `Time：${timeLeft}s`;
    }

    function initGrid(){
      grid = Array.from({length:GRID_SIZE}, ()=> Array.from({length:GRID_SIZE}, ()=> TYPES[Math.floor(Math.random()*TYPES.length)]));
      // 開局消連
      while (hasMatches()){
        const _tmp=eliminate(false); if(_tmp && _tmp.marks){ for(let i=0;i<GRID_SIZE;i++){ for(let j=0;j<GRID_SIZE;j++){ if(_tmp.marks[i][j]) grid[i][j]=null; } } }
        drop();
      }
      render();
    }

    function isAdj(a,b){ return (Math.abs(a.x-b.x)===1 && a.y===b.y) || (Math.abs(a.y-b.y)===1 && a.x===b.x); }

    function onCellClick(e){
      if(!running) return;
      const x = +e.target.dataset.x, y = +e.target.dataset.y;
      if(!selected){
        selected = {x,y}; render();
      } else {
        const prev = selected; selected = null;
        if (isAdj({x,y}, prev) && swapAndCheck({x,y}, prev)){
          chainResolve();
        } else render();
      }
    }

    function swapAndCheck(a,b){
      [grid[a.x][a.y], grid[b.x][b.y]] = [grid[b.x][b.y], grid[a.x][a.y]];
      if(!hasMatches()){
        [grid[a.x][a.y], grid[b.x][b.y]] = [grid[b.x][b.y], grid[a.x][a.y]];
        return false;
      }
      return true;
    }

    function hasMatches(){
      for(let i=0;i<GRID_SIZE;i++){
        for(let j=0;j<GRID_SIZE-2;j++){
          if(grid[i][j] && grid[i][j]===grid[i][j+1] && grid[i][j]===grid[i][j+2]) return true;
        }
      }
      for(let j=0;j<GRID_SIZE;j++){
        for(let i=0;i<GRID_SIZE-2;i++){
          if(grid[i][j] && grid[i][j]===grid[i+1][j] && grid[i][j]===grid[i+2][j]) return true;
        }
      }
      return false;
    }

    
    function eliminate(addScore = true){
      // phase 1: find matches
      const marks = Array.from({length:GRID_SIZE}, ()=> Array(GRID_SIZE).fill(false));
      let any = false;
      // row
      for(let i=0;i<GRID_SIZE;i++){
        for(let j=0;j<GRID_SIZE-2;j++){
          const v = grid[i][j];
          if(v && v===grid[i][j+1] && v===grid[i][j+2]){
            let len=3; while(j+len<GRID_SIZE && grid[i][j+len]===v) len++;
            for(let k=0;k<len;k++) marks[i][j+k]=true;
            j += len-1; any = true;
          }
        }
      }
      // col
      for(let j=0;j<GRID_SIZE;j++){
        for(let i=0;i<GRID_SIZE-2;i++){
          const v=grid[i][j];
          if(v && v===grid[i+1][j] && v===grid[i+2][j]){
            let len=3; while(i+len<GRID_SIZE && grid[i+len][j]===v) len++;
            for(let k=0;k<len;k++) marks[i+k][j]=true;
            i += len-1; any = true;
          }
        }
      }
      if(!any) return 0;
      // add score & mark DOM
      let cleared = 0;
      for(let i=0;i<GRID_SIZE;i++){
        for(let j=0;j<GRID_SIZE;j++){
          if(marks[i][j]){
            cleared++;
            if(addScore) score += 10; // 簡化：一次 +10（可再依長度加成）
          }
        }
      }
      // render with .clearing
      render();
      // add .clearing classes
      document.querySelectorAll('.cell').forEach(d=>{
        const x=+d.dataset.x, y=+d.dataset.y;
        if(marks[x][y]) d.classList.add('clearing');
      });
      return {cleared, marks};
    }


    function drop(){
      for(let j=0;j<GRID_SIZE;j++){
        let empty = GRID_SIZE-1;
        for(let i=GRID_SIZE-1;i>=0;i--){
          if(grid[i][j]){
            grid[empty][j]=grid[i][j];
            if(i!==empty) grid[i][j]=null;
            empty--;
          }
        }
        for(let i=0;i<=empty;i++){
          grid[i][j] = TYPES[Math.floor(Math.random()*TYPES.length)];
        }
      }
    }

    function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }
    async function chainResolve(){
      // 連消：有得消就持續
      do{
        const res = eliminate(true);
        if(res && res.marks){
          await delay(160);
          // phase 2: null & drop
          for(let i=0;i<GRID_SIZE;i++){
            for(let j=0;j<GRID_SIZE;j++){
              if(res.marks[i][j]) grid[i][j]=null;
            }
          }
          drop();
          render();
          await delay(80);
        }
      } while (hasMatches());
      if(score>=200){ unlock(); }
    }

    function tick(){
      timeLeft--;
      pillTime.textContent = `Time：${timeLeft}s`;
      if(timeLeft<=0){ stop('⏱️ 時間到！請再試一次'); return; }
      setTimeout(tick,1000);
    }

    function start(){
      running = true; score = 0; timeLeft = 30; selected = null;
      pillStatus.textContent='遊戲開始！'; btnStart.style.display='none'; btnRetry.style.display='none';
      initGrid();
      setTimeout(tick,1000);
    }

    function stop(msg){
      running = false; pillStatus.textContent = msg; btnRetry.style.display='inline-flex';
    }

    function toast(msg){
      const t = document.getElementById('toast'); t.textContent = msg; t.style.display='block';
      setTimeout(()=> t.style.display='none', 1600);
    }

    // ✅ 解鎖後 2 秒自動跳轉到精靈頁
    function unlock(){
      running = false;
      const spirit = { id:'spirit_game3', name:'飲茶仔', image:'images/game-spirit3.png', page:'spirit_game3.html',
        unlockDate:new Date().toISOString(), score:score };
      let spirits = JSON.parse(localStorage.getItem('spirits') || '[]');
      if(!spirits.some(s=>s.id===spirit.id)){
        spirits.push(spirit); localStorage.setItem('spirits', JSON.stringify(spirits));
        toast('🎉 已解鎖：飲茶仔！'); pillStatus.textContent='🎉 成功解鎖挑戰精靈：飲茶仔！';
      } else {
        pillStatus.textContent='你已經解鎖過飲茶仔喇！';
      }
      btnRetry.style.display='inline-flex';

      // 延遲 2 秒自動跳轉（可自行改時間）
      setTimeout(()=>{ window.location.href = spirit.page; }, 2000);
    }

    btnStart.addEventListener('click', start);
    btnRetry.addEventListener('click', start);
    // 預先生成棋盤（未開始可互動會被忽略）
    initGrid();
    pillStatus.textContent = '點「開始遊戲」就可以玩啦';
  </script>
</body>
</html>
